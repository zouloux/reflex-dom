{"mappings":"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","sources":["src/reflex/index.ts","src/reflex/common.ts","src/reflex/state.ts","src/reflex/diff.ts","src/reflex/jsx.ts","src/reflex/component.ts","src/reflex/render.ts","src/reflex/observable.ts","node_modules/@zouloux/signal/dist/index.es2020.mjs","node_modules/@zouloux/signal/dist/signal.es2020.mjs","node_modules/@zouloux/signal/dist/state-signal.es2020.mjs","node_modules/@zouloux/signal/dist/observable.es2020.mjs","src/reflex/ref.ts","src/reflex/lifecycle.ts","src/reflex/debug.ts","demos/demoHelpers.ts"],"sourcesContent":["/// <reference lib=\"dom\" />\n// ----------------------------------------------------------------------------- IMPORT / EXPORT\n\n/**\n * REFLEX JS\n *\n * - Reflex Core\n * \t\t- Core\n * \t\t- Polyfills\n * \t\t- Signal + Observer\n * \t\t- YADL\n * \t\t- Utils\n * - Reflex Components\n * \t\t- Reflex View (vdom + web components)\n * \t\t- Reflex Store\n * \t\t\t- Regular store / Async store or one big store well-made\n * \t\t- Reflex Router\n * \t\t\t- Based on Reflex Store\n * \t\t- Reflex Tween ?\n *\t\t- Reflex Toolkit\n *\t\t\t- Hooks\n *\t\t\t- Responsive\n *\t\t\t- Inputs\n *\t\t\t- Cursor\n *\t\t\t- Sound\n *\t\t\t- Viewport\n *\t\t- Reflex UI Kit\n *\t\t\t- mixins\n *\t\t\t- UI Kit\n *\t\t\t- Components ( Slideshow / Menu / Player ... )\n * - Reflex Server\n *\n */\n\n/**\n * FEATURES :\n *\n * - Basic v-dom\n * \t âœ” Create / remove elements\n * \t âœ” Set / remove attributes\n * \t âœ” Set / remove event listeners\n * \t âœ” Reuse previous components, do not trash everything everytime\n * \t âœ” innerHTML\n *   âœ” Class as string or array filtered with booleans\n *   \t- Optimize class when does not changes, is it possible ?\n *   âœ” Style as object only\n *   \t- Optimize style when does not changes, is it possible ?\n *\n * - Advanced v-dom\n *   âœ” Move elements and keep track of dom elements with keyed virtual nodes\n *   \tâœ” Add to top\n *   \tâœ” Add to bottom\n *   \tâœ” Remove from top\n *   \tâœ” Remove from bottom\n *   \tâœ” Insert in the middle\n *      âœ” Remove from the middle\n *      âœ” Basic swap\n *  \tX Optimized Swap\n *  \t\t- Do 2 operations, should do only one\n *   âœ” Keep track of component instances\n *   âœ” Remove subtrees recursively\n *   âœ” Sub tree rendering\n *   âœ” Rendering optimization (like memo and skip)\n *\n * - Reactive\n *   âœ” Dom ref / component ref\n *   âœ” Factory helpers (like hooks), find name and prefix\n *   âœ” Var in ref as let ! Yeah\n *   âœ” States / observers\n *   âœ” Stores\n *   âœ” Mount / Unmount\n *   âœ” Updated + Props\n *\n * - Advanced Reactive\n *   - Multi refs in for loops and stuff, need to keep correct indexes even when moving\n *   - Factory Errors / Component errors ( try catch on instance + render etc )\n *   - Async states ! With cancellation\n *   - Fetch hook with race condition management + states + cache + cancellable\n *   - Imperative handles\n *\n * - Types\n * \t - Basic JSX Type\n * \t - Render and component return JSX Types\n * \t - Props types\n *\n * - Release\n * \t - Optimize\n * \t - Benchmark\n * \t - Docs\n * \t - Release\n *\n * V2 :\n * - Advanced Hot Module reloading with state keeping automagically\n */\n\nexport * from \"./common\"\nexport * from \"./state\"\nexport * from \"./ref\"\nexport * from \"./lifecycle\"\nexport { render } from \"./render\"\n// Also export createElement for JSX pragma React\nexport { h, h as createElement } from \"./jsx\"\n","import { IRef, IRefs } from \"./ref\";\nimport { ComponentInstance } from \"./component\";\n\n// ----------------------------------------------------------------------------- TYPES\n\n// Declare global JSX override hack\n// declare global {\n// \tnamespace JSX {\n//\n// \t}\n// }\n\n// ----------------------------------------------------------------------------- CONSTANTS\n\n// Name of private node types which should not be created with JSX\n\nexport const _TEXT_NODE_TYPE_NAME = \"#Text\"\nexport const _ROOT_NODE_TYPE_NAME = \"#Root\"\n\n// ----------------------------------------------------------------------------- ERRORS\n\nexport class ReflexError extends Error {}\n\n// ----------------------------------------------------------------------------- POLYFILLS\n\nexport const microtask = ( window.queueMicrotask ?? (h => window.setTimeout( h, 0 )) )\n\n// ----------------------------------------------------------------------------- UTILS\n\n// Force a list or a lonely item to be an array with the same type\nexport const forceArray = <G>( item:G|G[] ):G[] => Array.isArray( item ) ? item : [ item ]\n\n\nexport function flattenChildren ( vnode:VNode ) {\n\t// Re-assign flattened array to the original virtual node, and return it\n\treturn vnode.props.children = (vnode.props?.children?.flat() ?? [])\n}\n\n// ----------------------------------------------------------------------------- INTERNAL - CREATE COMPONENT\n\nexport type RenderDom = Element|Text\n\n// FIXME : Cannot be VNode[] in current implementation.\n// FIXME : Cannot be string in current implementation.\nexport type RenderFunction = () => VNode\nexport type FunctionalComponent = RenderFunction\nexport type ComponentReturn = RenderFunction|VNode\nexport type FactoryComponent = () => RenderFunction\nexport type ComponentFunction = FunctionalComponent|FactoryComponent\n\nexport type LifecycleHandler <GReturn = void> = (...rest) => GReturn\nexport type MountHandler = LifecycleHandler|LifecycleHandler<LifecycleHandler>\n\n// ----------------------------------------------------------------------------- JSX H / CREATE ELEMENT\n\nexport type VNodeDomType = keyof (HTMLElementTagNameMap|SVGElementTagNameMap)\nexport type InternalVNodeTypes = typeof _ROOT_NODE_TYPE_NAME | typeof _TEXT_NODE_TYPE_NAME\n\nexport interface VNodeBaseProps {\n\tchildren\t?:VNode[],\n\tkey\t\t\t?:string\n\tref\t\t\t?:IRef|IRefs\n\tpure\t\t?:boolean\n}\n\nexport interface VNode <\n\tGProps \t= VNodeBaseProps,\n\tGType \t= ( VNodeDomType | InternalVNodeTypes | ComponentFunction ),\n> {\n\ttype\t\t\t:GType\n\tprops\t\t\t:GProps\n\tkey\t\t\t\t:string\t// Allow numbers ?\n\tdom\t\t\t\t?:RenderDom\n\t_keys\t\t\t?:Map<string, VNode>\n\t_ref\t\t\t?:IRef | IRefs\n\t_component\t\t?:ComponentInstance\n\t_keep\t\t\t?:boolean\n}\n\nexport interface VTextNode extends VNode<{value:string}> {\n\ttype\t\t: typeof _TEXT_NODE_TYPE_NAME\n}\n\nexport type VNodeOrVNodes = VNode|VNode[]\n","import { getHookedComponent } from \"./diff\";\nimport { invalidateComponent } from \"./render\";\nimport {\n\tcreateAsyncObservable, createStateObservable, IAsyncObservable,\n\tIStateObservable, TInitialValue\n} from \"./observable\";\n\n// ----------------------------------------------------------------------------- STATE\n\nexport function state <GType> ( initialValue?:TInitialValue<GType> ):IStateObservable<GType> {\n\tconst component = getHookedComponent()\n\tconst observable = createStateObservable( initialValue, () => invalidateComponent( component ) )\n\tcomponent._observables.push( observable )\n\treturn observable\n}\n\n// ----------------------------------------------------------------------------- ASTNC STATE\n\nexport function asyncState <GType> ( initialValue?:TInitialValue<GType> ):IAsyncObservable<GType> {\n\tconst component = getHookedComponent()\n\t// TODO : Implement this\n\tconst observable = createAsyncObservable( initialValue, () => invalidateComponent( component ) )\n\t// TODO : We may need cancellable Promises. Maybe just use reject ? And throw errors in legacy mode.\n\tcomponent._observables.push( observable )\n\treturn observable\n}","import {\n\t_TEXT_NODE_TYPE_NAME, RenderDom, RenderFunction,\n\tVNode, VNodeDomType, VTextNode, ComponentFunction,\n\tComponentReturn, ReflexError, flattenChildren\n} from \"./common\";\nimport { cloneVNode } from \"./jsx\";\nimport { IInternalRef, IInternalRefs } from \"./ref\";\nimport { ComponentInstance, createComponentInstance, recursivelyUpdateMountState } from \"./component\";\n\n/**\n * TODO : Errors\n * - Disallow a component render function to return a component as main node !\n * \t\t\t() => <OtherComponent /> <- Forbidden\n * - Disallow a component which render an array\n * \t\t\t() => [<div />, <div />] <- Forbidden\n */\n\n// ----------------------------------------------------------------------------- CONSTANTS\n\n// Virtual node object is injected into associated dom elements with this name\nexport const _DOM_PRIVATE_VIRTUAL_NODE_KEY = \"__v\"\n\n// Attached listeners to a dom element are stored in this array\nexport const _DOM_PRIVATE_LISTENERS_KEY = \"__l\"\n\n// Stolen from Preact, to check if a style props is non-dimensional (does not need to add a unit)\nconst _IS_NON_DIMENSIONAL_REGEX = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n\n// Check if an event is a capture one\nconst _CAPTURE_REGEX = /Capture$/\n\n// ----------------------------------------------------------------------------- CURRENT SCOPED COMPONENT\n\n// We store current component in factory phase for hooks\nlet _hookedComponent:ComponentInstance = null\nexport function getHookedComponent ():ComponentInstance {\n\tif ( !_hookedComponent && process.env.NODE_ENV !== \"production\" )\n\t\tthrow new ReflexError(`Using hook outside of a factory component.`)\n\treturn _hookedComponent\n}\n\n// ----------------------------------------------------------------------------- COMMON\n\nfunction getEventNameAndKey ( name:string, dom:Element ) {\n\t// Note : Capture management stolen from Preact, thanks\n\tconst useCapture = name !== ( name = name.replace(_CAPTURE_REGEX, '') );\n\t// Infer correct casing for DOM built-in events:\n\tconst eventName = ( name.toLowerCase() in dom ? name.toLowerCase() : name ).slice(2)\n\t// Create unique key for this event\n\tconst eventKey = eventName + (useCapture ? 'C' : '')\n\treturn { eventName, eventKey, useCapture }\n}\n\n// Stolen from Preact, attach some style Ã  key / value to a dom element\nfunction setStyle ( style:CSSStyleDeclaration, key:string, value:string|null ) {\n\tif (key[0] === '-')\n\t\tstyle.setProperty(key, value);\n\telse if (value == null)\n\t\tstyle[key] = '';\n\t// FIXME : IS_NON_DIMENSIONAL_REGEX -> Is it really necessary ?\n\telse if (typeof value != 'number' || _IS_NON_DIMENSIONAL_REGEX.test(key))\n\t\tstyle[key] = value;\n\telse\n\t\tstyle[key] = value + 'px';\n}\n\nfunction updateNodeRef ( node:VNode ) {\n\tif ( !node._ref ) return;\n\t// Ref as refs\n\tif ( 'list' in node._ref ) {\n\t\t// FIXME : Type\n\t\t// FIXME : Keep track of index ? Do it from diffChildren maybe ?\n\t\t( node._ref as IInternalRefs ).setFromVNode( 0, node as any )\n\t} else {\n\t\t// FIXME : Type\n\t\t( node._ref as IInternalRef ).setFromVNode( node as any )\n\t}\n}\n\n// Shallow compare two objects, applied only for props between new and old virtual nodes.\n// Will not compare \"children\" which is always different\n// https://esbench.com/bench/62a138846c89f600a5701904\nconst shallowPropsCompare = ( a:object, b:object ) => (\n\t// Same amount of properties ?\n\tObject.keys(a).length === Object.keys(b).length\n\t// Every property exists in other object ?\n\t// Never test \"children\" property which is always different\n\t&& Object.keys(a).every( key => key === \"children\" || (b.hasOwnProperty(key) && a[key] === b[key]) )\n)\n\n// ----------------------------------------------------------------------------- DIFF ELEMENT\n\nexport function diffElement ( newNode:VNode, oldNode:VNode ) {\n\t// console.log(\"diffElement\", newNode, oldNode)\n\tconst isTextNode = newNode.type == _TEXT_NODE_TYPE_NAME\n\t// Get dom element from oldNode or create it\n\tconst dom:RenderDom = (\n\t\toldNode ? oldNode.dom : (\n\t\t\tisTextNode\n\t\t\t? document.createTextNode( (newNode as VTextNode).props.value )\n\t\t\t: document.createElement( newNode.type as VNodeDomType )\n\t\t)\n\t)\n\t// Update text contents\n\tif ( isTextNode && oldNode ) {\n\t\tconst { value } = (newNode as VTextNode).props;\n\t\t// Only when content has changed\n\t\tif ( value != (dom as Text).nodeValue )\n\t\t\t( dom as Text ).nodeValue = value\n\t}\n\t// Text nodes does not have attributes or events\n\tif ( isTextNode ) return dom\n\t// Remove attributes which are removed from old node\n\toldNode && Object.keys( oldNode.props ).map( name => {\n\t\t// Do not process children and remove only if not in new node\n\t\tif ( name === \"children\" ) return\n\t\tif ( name in newNode.props && newNode.props[ name ] === oldNode.props[ name ] )\n\t\t\treturn\n\t\t// Insert HTML directly without warning\n\t\tif ( name === \"innerHTML\" )\n\t\t\t( dom as Element ).innerHTML = \"\" // FIXME : Maybe use delete or null ?\n\t\t\t// Events starts with \"on\". On preact this is optimized with [0] == \"o\"\n\t\t// But recent benchmarks are pointing to startsWith usage as faster\n\t\telse if ( name.startsWith(\"on\") ) {\n\t\t\tconst { eventName, eventKey, useCapture } = getEventNameAndKey( name, dom as Element );\n\t\t\tdom.removeEventListener( eventName, dom[ _DOM_PRIVATE_LISTENERS_KEY ][ eventKey ], useCapture )\n\t\t}\n\t\t// Other attributes\n\t\telse {\n\t\t\t( dom as Element ).removeAttribute( name )\n\t\t}\n\t})\n\t// Update props\n\tObject.keys( newNode.props ).map( name => {\n\t\tif ( name === \"children\" ) return\n\t\tlet value = newNode.props[ name ];\n\t\t// Do not continue if attribute or event did not change\n\t\tif ( oldNode && name in oldNode.props && oldNode.props[ name ] === value )\n\t\t\treturn;\n\t\t// Insert HTML directly without warning\n\t\tif ( name === \"innerHTML\" )\n\t\t\t( dom as Element ).innerHTML = value\n\t\t// Events starts with \"on\". On preact this is optimized with [0] == \"o\"\n\t\t// But recent benchmarks are pointing to startsWith usage as faster\n\t\telse if ( name.startsWith(\"on\") ) {\n\t\t\tconst { eventName, eventKey, useCapture } = getEventNameAndKey( name, dom as Element );\n\t\t\t// Init a collection of handlers on the dom object as private property\n\t\t\tdom[ _DOM_PRIVATE_LISTENERS_KEY ] ??= new Map();\n\t\t\t// Store original listener to be able to remove it later\n\t\t\tdom[ _DOM_PRIVATE_LISTENERS_KEY ][ eventKey ] = value;\n\t\t\t// And attach listener\n\t\t\tdom.addEventListener( eventName, value, useCapture )\n\t\t}\n\t\t// Other attributes, just set right on the dom element\n\t\telse {\n\t\t\t// className as class for non jsx components\n\t\t\tif ( name === \"className\" )\n\t\t\t\tname = \"class\"\n\t\t\t// Manage class as arrays\n\t\t\tif ( name === \"class\" && Array.isArray( value ) )\n\t\t\t\tvalue = value.filter( v => v !== true && !!v ).join(\" \").trim()\n\t\t\t// Manage style as object only\n\t\t\telse if ( name === \"style\" && typeof value === \"object\" )\n\t\t\t\t// FIXME : Can it be optimized ? Maybe only setStyle when needed ?\n\t\t\t\treturn Object.keys( value ).map(\n\t\t\t\t\tk => setStyle( (dom as HTMLElement).style, k, value[k] )\n\t\t\t\t);\n\t\t\t// Remove falsy values\n\t\t\telse if ( value === false )\n\t\t\t\treturn;\n\t\t\t// FIXME : What about checked / disabled / autoplay ...\n\t\t\t// Set new attribute value\n\t\t\t( dom as Element ).setAttribute( name, value )\n\t\t}\n\t})\n\treturn dom;\n}\n\n// ----------------------------------------------------------------------------- DIFF CHILDREN\n\n/**\n * Note about performances\n * - Very important, avoid loops in loops ! Prefer 4 static loops at top level\n *   rather than 2 nested loops. n*4 is lower than n^n !\n */\nexport function diffChildren ( newParentNode:VNode, oldParentNode?:VNode ) {\n\t// console.log(\"Diff children\", newParentNode, oldParentNode)\n\t// Target new and old children.\n\tconst newChildren = newParentNode.props.children?.flat()\n\tconst oldChildren = oldParentNode?.props.children?.flat()\n\t// FIXME : If new does not have children but old does, we need to destroy old children components instances\n\tif ( !newChildren ) return;\n\tconst parentDom = newParentNode.dom as Element\n\t// Create key array on parent node to register keyed children\n\t// This will allow us to find any child by its key directly without\n\t// having to search for it\n\tnewParentNode._keys = new Map()\n\tconst registerKey = c => {\n\t\tif ( c?.key ) newParentNode._keys[ c.key ] = c\n\t}\n\t// This is a new parent node (no old), so no diffing\n\t// we juste process and add every child node\n\tif ( !oldChildren ) {\n\t\tnewChildren.map( newChildNode => {\n\t\t\tif (!newChildNode) return;\n\t\t\tdiffNode( newChildNode )\n\t\t\tparentDom.appendChild( newChildNode.dom )\n\t\t\t// Register this child with its key on its parent\n\t\t\tregisterKey( newChildNode )\n\t\t})\n\t\treturn;\n\t}\n\t// Map all new children keys into the keys register to avoid to use find\n\t// when searching for removed nodes\n\t// NOTE : About performances : 1st non-nested loop\n\tnewChildren.map( registerKey )\n\t// Check if an old keyed node has been removed and get which index are offset after removal\n\t// NOTE : About performances : 2nd non-nested loop\n\tconst lostIndexes = oldChildren.map(\n\t\toldChild => !!(oldChild?.key && !newParentNode._keys[oldChild.key] )\n\t)\n\t// Otherwise we need to compare between old and new tree\n\tconst oldParentKeys = oldParentNode._keys\n\tlet collapseCount = 0\n\t// NOTE : About performances : 3rd non-nested loop\n\tnewChildren.map( (newChildNode, i) => {\n\t\t// Collapsed corresponding index between old and new nodes\n\t\t// To be able to detect moves or if just collapsing because a top sibling\n\t\t// has been removed\n\t\tif ( lostIndexes[i] )\n\t\t\tcollapseCount ++\n\t\t/** REMOVED **/\n\t\t// If falsy, it's surely a child that has been removed with a ternary or a boolean\n\t\t// Do nothing else and do not mark old node to keep, so it will be removed\n\t\tif ( !newChildNode )\n\t\t\treturn;\n\t\t// Has key, same key found in old, same type on both\n\t\t/** MOVE & UPDATE KEYED CHILD **/\n\t\tif (\n\t\t\tnewChildNode.key\n\t\t\t&& oldParentKeys[ newChildNode.key ]\n\t\t\t&& oldParentKeys[ newChildNode.key ].type == newChildNode.type\n\t\t) {\n\t\t\tconst oldNode = oldParentKeys[ newChildNode.key ]\n\t\t\tdiffNode( newChildNode, oldNode )\n\t\t\toldNode.keep = true;\n\t\t\t// Check if index changed, compare with collapsed index to detect moves\n\t\t\tconst collapsedIndex = i + collapseCount\n\t\t\t// FIXME : Should do 1 operation when swapping positions, not 2\n\t\t\t// FIXME : Perf, is indexOf quick ? Maybe store every indexes in an array ?\n\t\t\tif ( oldChildren.indexOf( oldNode ) != collapsedIndex )\n\t\t\t\tparentDom.insertBefore( newChildNode.dom, parentDom.children[ i ] )\n\t\t}\n\t\t// Has key, but not found in old\n\t\t/** CREATE **/\n\t\telse if ( newChildNode.key && !oldParentKeys[ newChildNode.key ] ) {\n\t\t\tdiffNode( newChildNode )\n\t\t\tparentDom.insertBefore( newChildNode.dom, parentDom.children[ i ] )\n\t\t\tcollapseCount --\n\t\t}\n\t\t// Found at same index, with same type.\n\t\t// Old node does not have a key.\n\t\t/** UPDATE IN PLACE **/\n\t\telse if ( i in oldChildren && oldChildren[ i ] && oldChildren[ i ].type == newChildNode.type ) {\n\t\t\tconst oldNode = oldChildren[ i ]\n\t\t\tdiffNode( newChildNode, oldNode )\n\t\t\toldNode._keep = true;\n\t\t}\n\t\t// Not found\n\t\t/** CREATE **/\n\t\telse {\n\t\t\tdiffNode( newChildNode )\n\t\t\tparentDom.insertBefore( newChildNode.dom, parentDom.children[ i ] )\n\t\t\tcollapseCount --\n\t\t}\n\t})\n\t// Remove old children which are not reused\n\t// NOTE : About performances : 4th non-nested loop\n\toldChildren.map( oldChildNode => {\n\t\tif ( oldChildNode && !oldChildNode._keep ) {\n\t\t\t// Call unmount handlers\n\t\t\trecursivelyUpdateMountState( oldChildNode, false );\n\t\t\t// Remove ref\n\t\t\tconst { dom } = oldChildNode\n\t\t\toldChildNode.dom = null;\n\t\t\tupdateNodeRef( oldChildNode )\n\t\t\tparentDom.removeChild( dom )\n\t\t}\n\t})\n}\n\n// ----------------------------------------------------------------------------- DIFF NODE\n\nfunction renderComponentNode <GReturn = ComponentReturn> ( node:VNode<null, ComponentFunction>, component:ComponentInstance ) :GReturn {\n\t// Tie component and virtual node\n\tcomponent.vnode = node\n\tnode._component = component\n\t// Select hooked component\n\t_hookedComponent = component;\n\t// FIXME: Before render handlers ?\n\t// FIXME: Optimize rendering with a hook ?\n\t// Execute rendering\n\tconst result = (component._render ?? node.type as RenderFunction)\n\t\t.apply( component, [ component._propsProxy.value ])\n\t// Unselect hooked component\n\t_hookedComponent = null\n\treturn result as GReturn\n}\n\nexport function diffNode ( newNode:VNode, oldNode?:VNode ) {\n\t// IMPORTANT : Here we clone node if we got the same instance\n\t// \t\t\t   Otherwise, altering props.children after render will fuck everything up\n\t// Clone identical nodes to be able to diff them\n\tif ( oldNode && oldNode === newNode )\n\t\tnewNode = cloneVNode( oldNode )\n\t// Transfer component instance from old node to new node\n\tlet component:ComponentInstance = oldNode?._component\n\t// We may need a new component instance\n\tlet renderResult:VNode\n\tif ( !component && typeof newNode.type === \"function\" ) {\n\t\t// Create component instance (without new keyword for better performances)\n\t\tcomponent = createComponentInstance( newNode as VNode<null, ComponentFunction> )\n\t\t// Execute component's function and check what is returned\n\t\tconst result = renderComponentNode( newNode as VNode<null, ComponentFunction>, component )\n\t\t// This is a factory component which return a render function\n\t\tif ( typeof result === \"function\" ) {\n\t\t\tcomponent._render = result as RenderFunction\n\t\t\tcomponent.isFactory = true\n\t\t}\n\t\t// This is pure functional component which returns a virtual node\n\t\telse if ( typeof result == \"object\" && \"type\" in result ) {\n\t\t\tcomponent._render = newNode.type as RenderFunction\n\t\t\tcomponent.isFactory = false\n\t\t\trenderResult = result\n\t\t}\n\t}\n\tlet dom:RenderDom\n\t// Virtual node is a dom element\n\tif ( !component ) {\n\t\tnewNode.dom = dom = diffElement( newNode, oldNode )\n\t}\n\t// Virtual node is a component\n\telse {\n\t\t// FIXME : Is it a good idea to shallow compare props on every changes by component ?\n\t\t// \t\t\t-> It seems to be faster than preact + memo with this ðŸ‘€, check other cases\n\t\t// TODO : Maybe do not shallow by default but check if component got an \"optimize\" function\n\t\t//\t\t\twhich can be implemented with hooks. We can skip a lot with this !\n\t\t// FIXME : Does not work if props contain dynamic arrow functions :(\n\t\t//\t\t\t<Sub onEvent={ e => handler(e, i) } />\n\t\t//\t\t\tHere the handler is a different ref at each render\n\t\t// If props did not changed between old and new\n\t\t// Only optimize pure components, factory components mau have state so are not pure\n\t\tif (\n\t\t\t// If pure functional component has not already been rendered\n\t\t\t!renderResult\n\t\t\t// Need to be a component update, on a pure functional component,\n\t\t\t&& oldNode && !component.isFactory // && !component.isDirty\n\t\t\t// New component isn't marked as not pure\n\t\t\t&& newNode.props.pure !== false // FIXME : Rename it forceRefresh={ true } ?\n\t\t\t// Cannot optimize components which have children properties\n\t\t\t// Because parent component may have altered rendering of injected children\n\t\t\t&& newNode.props.children.length === 0\n\t\t\t// Do shallow compare\n\t\t\t&& shallowPropsCompare(newNode.props, oldNode.props)\n\t\t) {\n\t\t\t// FIXME : Weirdly, it seems to optimize not all components\n\t\t\t//\t\t\tEx : click on create 1000 several times and watch next console log\n\t\t\t// console.log(\"OPTIMIZE\")\n\t\t\t// Do not re-render, just get children and dom from old node\n\t\t\t// newNode.props.children = [ ...oldNode.props.children ]\n\t\t\tnewNode.props.children = oldNode.props.children\n\t\t\tnewNode.dom = dom = oldNode.dom\n\t\t}\n\t\t// Not already rendered, and not optimization possible. Render now.\n\t\telse if ( !renderResult ) {\n\t\t\tcomponent._propsProxy.set( newNode.props )\n\t\t\trenderResult = renderComponentNode<VNode>( newNode as VNode<null, ComponentFunction>, component )\n\t\t}\n\t\t// We rendered something (not reusing old component)\n\t\tif ( renderResult ) {\n\t\t\t// Apply new children list to the parent component node\n\t\t\tnewNode.props.children = flattenChildren( renderResult )\n\t\t\t// Diff rendered element\n\t\t\tnewNode.dom = dom = diffElement( renderResult, oldNode )\n\t\t\t// Assign ref of first virtual node to the component's virtual node\n\t\t\tnewNode._ref = renderResult._ref\n\t\t}\n\t\t// Tie up node and component\n\t\tnewNode._component = component\n\t\tcomponent.vnode = newNode as any\n\t\t// Component is clean and rendered now\n\t\tcomponent._isDirty = false\n\t}\n\t// Update ref on node\n\tupdateNodeRef( newNode )\n\t// Diff children of this element (do not process text nodes)\n\tif ( dom instanceof Element )\n\t\tdiffChildren( newNode, oldNode )\n\t// If component is not mounted yet, mount it recursively\n\tif ( component && !component.isMounted )\n\t\trecursivelyUpdateMountState( newNode, true )\n\t// Execute after render handlers\n\tcomponent?._renderHandlers.map( h => h() )\n}\n","import { _TEXT_NODE_TYPE_NAME, VNode } from \"./common\";\n\n// TODO : Move VNode type and VNode constants here (TEXT_NODE_TYPE_NAME)\n\n// NOTE : Keep it in a function and do not inline this\n// It seems to be V8 optimized. @see Preact source code\nexport function createVNode ( type, props, key?, ref? ):VNode {\n\treturn { type: type, props: props, key: key, _ref: ref }\n}\n\nexport function cloneVNode ( vnode:VNode ) {\n\treturn {\n\t\t...vnode,\n\t\t// IMPORTANT : also clone props object\n\t\tprops: { ...vnode.props }\n\t}\n}\n\nexport function h ( type, props, ...children ) {\n\t// Remove debug properties\n\t// FIXME : Keep them in debug mode ? But in vnode not in props.\n\tdelete props.__self\n\tdelete props.__source\n\t// Extract key and ref from props\n\tconst { key, ref, ...nodeProps } = props\n\t// Inject children in props\n\tnodeProps.children = ( children ?? [] ).map( child => (\n\t\t// Convert string and number children to text virtual nodes\n\t\t( [\"string\", \"number\"].indexOf( typeof child ) !== -1 )\n\t\t? createVNode( _TEXT_NODE_TYPE_NAME, { value: child + '' })\n\t\t// Otherwise keep child generated by JSX\n\t\t: child\n\t))\n\treturn createVNode( type, nodeProps, key, ref )\n}\n","import {\n\tComponentFunction, flattenChildren, LifecycleHandler, MountHandler, RenderFunction,\n\t_TEXT_NODE_TYPE_NAME, VNode, ReflexError\n} from \"./common\";\nimport { IStateObservable } from \"@zouloux/signal\";\n\n// ----------------------------------------------------------------------------- TYPES\n\nexport interface ComponentInstance { // FIXME : Generics ?\n\tvnode\t\t\t\t:VNode<null, ComponentFunction>\n\tname\t\t\t\t:string\n\tisFactory\t\t\t?:boolean\n\tisMounted\t\t\t:boolean;\n\t_isDirty\t\t\t?:boolean\n\t_render\t\t\t\t?:RenderFunction\n\t_propsProxy\t\t\t?:IPropsProxy<any>\n\t_mountHandlers\t\t:MountHandler[]\n\t_renderHandlers\t\t:LifecycleHandler[]\n\t_unmountHandlers\t:LifecycleHandler[]\n\t_observables\t\t:IStateObservable<any>[]\n\t// TODO : Imperative handlers ?\n}\n\n// ----------------------------------------------------------------------------- CREATE COMPONENT INSTANCE\n\n// Optimize it in a function @see jsx.ts/createVNode()\nexport function createComponentInstance ( vnode:VNode<null, ComponentFunction> ):ComponentInstance {\n\treturn {\n\t\tvnode,\n\t\t_propsProxy: createPropsProxy( vnode.props ),\n\t\t_isDirty: false,\n\t\tisMounted: false,\n\t\tname: vnode.type.name,\n\t\t_mountHandlers: [],\n\t\t_renderHandlers: [],\n\t\t_unmountHandlers: [],\n\t\t_observables: [],\n\t}\n}\n\n// ----------------------------------------------------------------------------- PROPS PROXY\n// Props proxy exists because we need a way to get updated props in a factory\n// component. Because factory function is executed once, props object passed\n// as first argument cannot be updated. Proxy helps us here because it will\n// allow us to mock props but with every props updated.\n// A caveat is that props is not iterable because proxy is a dynamic key / value\n// object. Not really concerning because it makes no sense to iterate over\n// a props object.\n\nexport interface IPropsProxy <GType> {\n\treadonly value:GType\n\tset ( newValue:GType ) : void\n}\n\nfunction createPropsProxy <GProps> ( props:GProps ) : IPropsProxy<GProps> {\n\tconst proxy = new Proxy({}, {\n\t\t// When request a prop, check on props object if it exists\n\t\tget ( target:{}, propName:string|symbol ):any {\n\t\t\treturn ( propName in props ? props[ propName ] : undefined )\n\t\t},\n\t\t// Disallow set on props\n\t\tset () {\n\t\t\tthrow new ReflexError(`PropsProxy.set // Setting values to props manually is not allowed.`)\n\t\t}\n\t})\n\treturn {\n\t\t// Get the proxy object typed as a GProps object\n\t\tget value () { return proxy as GProps },\n\t\t// This method will set new props object (we override first argument of createPropsProxy)\n\t\tset ( newProps:GProps ) { props = newProps }\n\t}\n}\n\n// ----------------------------------------------------------------------------- MOUNT / UNMOUNT\n\nexport function mountComponent ( component:ComponentInstance ) {\n\t// Call every mount handler and store returned unmount handlers\n\tcomponent._mountHandlers.map( handler => {\n\t\tconst mountedReturn = handler.apply( component, [] );\n\t\tif ( typeof mountedReturn === \"function\" )\n\t\t\tcomponent._unmountHandlers.push( mountedReturn )\n\t})\n\t// Reset mount handlers, no need to keep them\n\tcomponent._mountHandlers = []\n\tcomponent.isMounted = true;\n}\n\nexport function unmountComponent ( component:ComponentInstance ) {\n\tcomponent._unmountHandlers.map( h => h.apply( component, [] ) )\n\tcomponent._observables.map( o => o.dispose() )\n\t// FIXME : Do we need to do this ? Is it efficient or is it just noise ?\n\t//delete component.vnode\n\t// delete component.propsProxy\n\tdelete component._mountHandlers;\n\tdelete component._renderHandlers;\n\tdelete component._unmountHandlers;\n\tdelete component._observables\n\tcomponent.isMounted = false;\n}\n\nexport function recursivelyUpdateMountState ( node:VNode, doMount:boolean ) {\n\tif ( node.type == _TEXT_NODE_TYPE_NAME ) return\n\tflattenChildren( node ).map( c => c && recursivelyUpdateMountState(c, doMount) )\n\tif ( node._component )\n\t\tdoMount ? mountComponent( node._component ) : unmountComponent( node._component )\n}","import { _ROOT_NODE_TYPE_NAME, forceArray, VNodeOrVNodes, microtask } from \"./common\";\nimport { diffChildren, diffNode, _DOM_PRIVATE_VIRTUAL_NODE_KEY } from \"./diff\";\nimport { createVNode } from \"./jsx\";\nimport { ComponentInstance } from \"./component\";\n\n// ----------------------------------------------------------------------------- RENDER\n\nexport function render ( rootNode:VNodeOrVNodes, parentElement:HTMLElement ) {\n\t// When using render, we create a new root node to detect new renders\n\t// This node is never rendered, we just attach it to the parentElement and render its children\n\tconst root = createVNode( _ROOT_NODE_TYPE_NAME, { children: forceArray( rootNode ) })\n\troot.dom = parentElement\n\tdiffChildren( root, parentElement[ _DOM_PRIVATE_VIRTUAL_NODE_KEY ] )\n\tparentElement[ _DOM_PRIVATE_VIRTUAL_NODE_KEY ] = root\n}\n\n// ----------------------------------------------------------------------------- INVALIDATION\n\nlet componentsToUpdate:ComponentInstance[] = []\nfunction updateDirtyComponents () {\n\tlet p\n\tif ( process.env.NODE_ENV !== \"production\" )\n\t\tp = require(\"./debug\").trackPerformances(\"Update dirty components\")\n\t// TODO : Update with depth ! Deepest first ? Or last ?\n\tcomponentsToUpdate.map( component => {\n\t\tdiffNode( component.vnode, component.vnode )\n\t})\n\tcomponentsToUpdate = []\n\tp && p();\n}\n\nexport function invalidateComponent ( component:ComponentInstance ) {\n\t// Queue rendering before end of frame\n\tif ( componentsToUpdate.length === 0 )\n\t\tmicrotask( updateDirtyComponents );\n\t// Invalidate this component once\n\tif ( component._isDirty ) return;\n\tcomponent._isDirty = true\n\t// Store it into the list of dirty components\n\tcomponentsToUpdate.push( component )\n}\n\n// ----------------------------------------------------------------------------- REGISTER WEB-COMPONENTS\n\n// TODO : Web components ! Check how lit and preact webcomponents works\n//\t\t\t- Register web-components with ComponentName to <component-name />\n//  \t\t- Update properties when changed in DOM\n//  \t\t\t- Need translation (detect numbers, maybe json for array and objects ?)\n//\t\t\t\t- Maybe an API to set props with JS and with advanced type (like functions)\n//\t\t\t- Children\n//\t\t\t- DOM Find\n//\t\t\t- Mount / Unmount\n\n// ----------------------------------------------------------------------------- HYDRATE\n\n// TODO : Hydrate\n// TODO : Render to string or render to web components to avoid expensive hydratation ?\n\n","import { Signal, ISignal } from \"@zouloux/signal\";\n\n// ----------------------------------------------------------------------------- COMMON TYPES\n\nexport type TChangedHandler<GType, GReturnType = void> = ( newValue:GType, oldValue:GType) => GReturnType|Promise<GReturnType>\n\nexport type TSignalWithoutDispatch <GSignalArguments extends any[]> = Omit<ISignal<GSignalArguments>, \"dispatch\">\n\n// ----------------------------------------------------------------------------- PREPARE INITIAL VALUE\n\nexport type TInitialValue<GType> = GType | (() => GType)\n\nfunction prepareInitialValue <GType> ( initialValue:TInitialValue<GType> ) {\n\treturn (\n\t\ttypeof initialValue === \"function\"\n\t\t? ( initialValue as () => GType )()\n\t\t: initialValue as GType\n\t)\n}\n\n// ----------------------------------------------------------------------------- BIT\n\nexport interface IPublicBit <GType> {\n\tonChanged\t\t:TSignalWithoutDispatch<[GType, GType]>\n\tdispose \t\t() : void\n}\n\nexport interface IBit <GType> extends IPublicBit <GType> {\n\tget () : GType\n\tset ( newValue:GType ) : void\n\tdispatch ( newValue:GType, oldValue:GType ) : any|void\n}\n\n/**\n * A bit is a piece of data associated to a signal, a getter and a setter.\n * A raw bit does not dispatch the signal when set on purpose. It's meant to be\n * used by an upper function which holds dispatch as a private member.\n * @param initialValue Initial value or initial value generator.\n */\nexport function createBit <GType> ( initialValue?:TInitialValue<GType> ):IBit<GType> {\n\t// Init and store the value in this scope\n\tlet value:GType = prepareInitialValue( initialValue )\n\t// Create signal and extract dispatch method from it\n\t// So code accessing signal externally would not be able to dispatch and mess\n\tconst onChanged = Signal<[GType, GType]>()\n\tconst { dispatch } = onChanged\n\tonChanged.dispatch = null;\n\t// Return bit API\n\treturn {\n\t\tonChanged,\n\t\tdispatch,\n\t\tget () { return value },\n\t\tset ( newValue:GType ) { value = newValue; },\n\t\tdispose () {\n\t\t\tonChanged.clear();\n\t\t\tvalue = null;\n\t\t}\n\t}\n}\n\n// ----------------------------------------------------------------------------- BASIC OBSERVABLE\n\nexport interface IBasicObservable <GType> extends IPublicBit <GType> {\n\treadonly value:GType\n\tset ( newValue:TInitialValue<GType> ) : void\n}\n\n/**\n * The simplest observable, holds a value a\tand dispatch when mutated.\n * No shallow check, no invalidation step, not cancellable.\n * Everything is synchronous.\n * Has a private _dispose method to destroy it from memory.\n * @param initialValue Initial value or initial value generator.\n */\nexport function createBasicObservable <GType> ( initialValue?:TInitialValue<GType> ):IBasicObservable<GType> {\n\t// Create the bit and extract private dispatch and setter\n\t// const { get, set, dispatch, ...bit } = createBit<GType>( initialValue );\n\tconst bit = createBit<GType>( initialValue );\n\treturn {\n\t\t// ...bit,\n\t\tonChanged: bit.onChanged,\n\t\tdispose: bit.dispose,\n\t\tget value () { return bit.get() },\n\t\tset ( newValue:GType) {\n\t\t\tconst oldValue = bit.get();\n\t\t\tbit.set( newValue );\n\t\t\tbit.dispatch( newValue, oldValue )\n\t\t}\n\t}\n}\n\n// ----------------------------------------------------------------------------- STATE OBSERVABLE\n\nexport interface IStateObservable <GType> extends IBasicObservable <GType> {\n\tset ( newValue:TInitialValue<GType> ) : Promise<void>\n}\n\nexport function createStateObservable <GType> (\n\tinitialValue\t?:TInitialValue<GType>,\n\tbeforeChanged\t?:TChangedHandler<GType, boolean|void>\n):IStateObservable<GType> {\n\t// Create the bit and extract private dispatch and setter\n\t// TODO : IMPORTANT : Weirdly, we can destruct like this with tsc\n\t// \tget value () { return get() } will not work and always return initial value\n\t// const { get, set, dispatch, ...bit } = createBit<GType>( initialValue );\n\tconst bit = createBit<GType>( initialValue );\n\treturn {\n\t\t// ...bit,\n\t\tonChanged: bit.onChanged,\n\t\tdispose: bit.dispose,\n\t\tget value () { return bit.get() },\n\t\tasync set ( newValue:GType ) {\n\t\t\tconst oldValue = bit.get();\n\t\t\tbit.set( newValue );\n\t\t\tif ( beforeChanged ) {\n\t\t\t\t// isLocked = true;\n\t\t\t\tconst haltChange = await beforeChanged( newValue, oldValue )\n\t\t\t\tif ( haltChange === true ) {\n\t\t\t\t\tbit.set( oldValue );\n\t\t\t\t\t// isLocked = false;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// isLocked = false;\n\t\t\tbit.dispatch( newValue, oldValue );\n\t\t}\n\t}\n}\n\n// ----------------------------------------------------------------------------- ASYNC OBSERVABLE\n\nexport interface IAsyncObservable <GType> extends IStateObservable <GType> {\n\treadonly isChanging\t\t\t:boolean\n\treadonly wasAlreadyChanging\t:boolean\n}\n\nexport function createAsyncObservable <GType> (\n\tinitialValue\t?:TInitialValue<GType>,\n\tbeforeChanged\t?:TChangedHandler<GType, boolean|void>\n):IAsyncObservable<GType> {\n\t// Create the bit and extract private dispatch and setter\n\t// const { get, set, dispatch, ...bit } = createBit<GType>( initialValue );\n\tconst bit = createBit<GType>( initialValue );\n\tlet isChanging = false\n\tlet wasAlreadyChanging = false\n\treturn {\n\t\t// ...bit,\n\t\tonChanged: bit.onChanged,\n\t\tdispose: bit.dispose,\n\t\tget value () { return bit.get() },\n\t\tget isChanging () { return isChanging },\n\t\tget wasAlreadyChanging () { return wasAlreadyChanging },\n\t\tasync set ( newValue:GType ) {\n\t\t\t// Keep old to check changes\n\t\t\tconst oldValue = bit.get();\n\t\t\tbit.set( newValue )\n\t\t\t// Call private changed as async (may change state asynchronously)\n\t\t\tif ( beforeChanged ) {\n\t\t\t\tif ( isChanging )\n\t\t\t\t\twasAlreadyChanging = true\n\t\t\t\tisChanging = true;\n\t\t\t\tconst haltChange = await beforeChanged( newValue, oldValue )\n\t\t\t\tif ( haltChange === true ) {\n\t\t\t\t\tbit.set( oldValue )\n\t\t\t\t\tisChanging = false\n\t\t\t\t\twasAlreadyChanging = false\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tisChanging = false\n\t\t\t\tif ( wasAlreadyChanging ) {\n\t\t\t\t\twasAlreadyChanging = false\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Call public onChange signal with new and old values\n\t\t\tbit.dispatch( newValue, oldValue )\n\t\t}\n\t}\n}\n","export * from \"./signal.es2020.mjs\";\nexport * from \"./state-signal.es2020.mjs\";\nexport * from \"./observable.es2020.mjs\";\n","// TODO v1.1 RC\n// -> Better generic types that can leak from dispatch, without generic set at init\n// -> Better generic types which respect type order for GHP\n// ----------------------------------------------------------------------------- CLASSIC SIGNAL\nexport function Signal() {\n    // List of attached listeners\n    let _listeners = [];\n    // Remove a listener by its reference\n    const remove = (handler) => _listeners = _listeners.filter(l => l[0] !== handler);\n    // Add a listener with once and call at init parameters\n    function add(handler, once, callAtInit = false) {\n        // Add listener\n        _listeners.push([handler, once]);\n        // Call at init with parameters if callAtInit is an array of parameters\n        // Just call without parameters if callAtInit is true\n        callAtInit && handler.apply(null, Array.isArray(callAtInit) ? callAtInit : null);\n        // Return a handler which will remove this listener\n        // Very handy with React hooks like useLayoutEffect\n        return () => remove(handler);\n    }\n    // Return public API\n    return {\n        // Add and return a remove thunk\n        add(handler, callAtInit = false) {\n            return add(handler, false, callAtInit);\n        },\n        // Add once and return a remove thunk\n        once(handler) {\n            return add(handler, true);\n        },\n        remove,\n        dispatch: (...rest) => _listeners.map(listener => {\n            // Remove listener if this is a once\n            listener[1] && remove(listener[0]);\n            // Execute with parameters\n            return listener[0](...rest);\n        }),\n        clear() { _listeners = []; },\n        get listeners() { return _listeners.map(l => l[0]); }\n    };\n}\nexport default Signal;\n","import { Signal } from \"./signal.es2020.mjs\";\n// ----------------------------------------------------------------------------- STATE SIGNAL\nexport function StateSignal(_state = null, _signal = Signal()) {\n    return {\n        ..._signal,\n        get state() { return _state; },\n        // Add and return a remove thunk\n        add(handler, callAtInit = false) {\n            // Call at init will dispatch current state and not a configurable array of props\n            return _signal.add(handler, callAtInit === true ? [_state] : false);\n        },\n        // Add once and return a remove thunk\n        once(handler) {\n            return _signal.once(handler);\n        },\n        dispatch(state) {\n            _state = state;\n            return _signal.dispatch(state);\n        },\n        // Remove listeners and stored state\n        clear() {\n            _signal.clear();\n            _state = null;\n        }\n    };\n}\n","import { Signal } from \"./signal.es2020.mjs\";\nfunction prepareInitialValue(initialValue) {\n    return (typeof initialValue === \"function\"\n        ? initialValue()\n        : initialValue);\n}\n/**\n * A bit is a piece of data associated to a signal, a getter and a setter.\n * A raw bit does not dispatch the signal when set on purpose. It's meant to be\n * used by an upper function which holds dispatch as a private member.\n * @param initialValue Initial value or initial value generator.\n */\nexport function createBit(initialValue) {\n    // Init and store the value in this scope\n    let value = prepareInitialValue(initialValue);\n    // Create signal and extract dispatch method from it\n    // So code accessing signal externally would not be able to dispatch and mess\n    const onChanged = Signal();\n    const { dispatch } = onChanged;\n    onChanged.dispatch = null;\n    // Return bit API\n    return {\n        onChanged,\n        dispatch,\n        get() { return value; },\n        set(newValue) { value = newValue; },\n        dispose() {\n            onChanged.clear();\n            value = null;\n        }\n    };\n}\n/**\n * The simplest observable, holds a value a\tand dispatch when mutated.\n * No shallow check, no invalidation step, not cancellable.\n * Everything is synchronous.\n * Has a private _dispose method to destroy it from memory.\n * @param initialValue Initial value or initial value generator.\n */\nexport function createBasicObservable(initialValue) {\n    // Create the bit and extract private dispatch and setter\n    const { get, set, dispatch, ...bit } = createBit(initialValue);\n    return {\n        ...bit,\n        get value() { return get(); },\n        set(newValue) {\n            const oldValue = get();\n            set(newValue);\n            dispatch(newValue, oldValue);\n        }\n    };\n}\nexport function createStateObservable(initialValue, beforeChanged) {\n    // Create the bit and extract private dispatch and setter\n    const { get, set, dispatch, ...bit } = createBit(initialValue);\n    return {\n        ...bit,\n        get value() { return get(); },\n        async set(newValue) {\n            const oldValue = get();\n            set(newValue);\n            if (beforeChanged) {\n                // isLocked = true;\n                const haltChange = await beforeChanged(newValue, oldValue);\n                if (haltChange === true) {\n                    set(oldValue);\n                    // isLocked = false;\n                    return;\n                }\n            }\n            // isLocked = false;\n            dispatch(newValue, oldValue);\n        }\n    };\n}\nexport function createAsyncObservable(initialValue, beforeChanged) {\n    // Create the bit and extract private dispatch and setter\n    const { get, set, dispatch, ...bit } = createBit(initialValue);\n    let isChanging = false;\n    let wasAlreadyChanging = false;\n    return {\n        ...bit,\n        get value() { return get(); },\n        get isChanging() { return isChanging; },\n        get wasAlreadyChanging() { return wasAlreadyChanging; },\n        async set(newValue) {\n            // Keep old to check changes\n            const oldValue = get();\n            set(newValue);\n            // Call private changed as async (may change state asynchronously)\n            if (beforeChanged) {\n                if (isChanging)\n                    wasAlreadyChanging = true;\n                isChanging = true;\n                const haltChange = await beforeChanged(newValue, oldValue);\n                if (haltChange === true) {\n                    set(oldValue);\n                    isChanging = false;\n                    wasAlreadyChanging = false;\n                    return;\n                }\n                isChanging = false;\n                if (wasAlreadyChanging) {\n                    wasAlreadyChanging = false;\n                    return;\n                }\n            }\n            // Call public onChange signal with new and old values\n            dispatch(newValue, oldValue);\n        }\n    };\n}\n","import { VNode, VNodeBaseProps } from \"./common\";\nimport { ComponentInstance } from \"./component\";\n\n// ----------------------------------------------------------------------------- REF\n\nexport interface IRef <\n\tGDom extends Element = Element,\n\tGComponent extends ComponentInstance = ComponentInstance,\n> {\n\tdom\t\t\t\t:GDom\n\tcomponent\t\t:GComponent\n}\n\nexport interface IInternalRef <\n\tGDom extends Element = Element,\n\tGComponent extends ComponentInstance = ComponentInstance,\n> extends IRef {\n\tsetFromVNode\t: ( vnode:VNode<VNodeBaseProps, GComponent> ) => void\n}\n\nexport function ref <\n\tGDom extends Element = Element,\n\tGComponent extends ComponentInstance = ComponentInstance,\n> ():IRef<GDom, GComponent> {\n\tconst value:IInternalRef<GDom, GComponent> = {\n\t\tcomponent: null,\n\t\tdom: null,\n\t\tsetFromVNode ( vnode:VNode<VNodeBaseProps, GComponent> ) {\n\t\t\tvalue.dom \t\t= vnode.dom as GDom;\n\t\t\tvalue.component = vnode._component as GComponent;\n\t\t}\n\t}\n\treturn value as never as IRef<GDom, GComponent>;\n}\n\n// ----------------------------------------------------------------------------- REFS\n\nexport interface IRefs <\n\tGDom extends Element = Element,\n\tGComponent extends ComponentInstance = ComponentInstance,\n\t> {\n\tlist : IRef<GDom, GComponent>[]\n}\n\nexport interface IInternalRefs <\n\tGDom extends Element = Element,\n\tGComponent extends ComponentInstance = ComponentInstance,\n\t> extends IRefs {\n\tsetFromVNode\t: ( index:number, vnode:VNode<VNodeBaseProps, GComponent> ) => void\n}\n\nexport function refs <\n\tGComponent extends ComponentInstance = ComponentInstance,\n\tGDom extends Element = Element,\n> ():IRefs<GDom, GComponent> {\n\tconst value:IInternalRefs<GDom, GComponent> = {\n\t\tlist: [],\n\t\tsetFromVNode ( index:number, vnode:VNode<VNodeBaseProps, GComponent> ) {\n\t\t\t// Delete\n\t\t\tif ( vnode == null ) {\n\t\t\t\tdelete value.list[ index ]\n\t\t\t\tvalue.list.length --\n\t\t\t// Update\n\t\t\t} else if ( index in value.list ) {\n\t\t\t\tvalue.list[ index ].component\t= vnode._component as GComponent;\n\t\t\t\tvalue.list[ index ].dom \t \t= vnode.dom as GDom;\n\t\t\t// Create\n\t\t\t} else {\n\t\t\t\tvalue.list[ index ] = {\n\t\t\t\t\tdom \t\t: vnode.dom as GDom,\n\t\t\t\t\tcomponent\t: vnode._component as GComponent,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn value as never as IRefs<GDom, GComponent>;\n}\n\n// FIXME : When using web components with original dom not from Reflex\n// FIXME : Move it in module web-components ?\n// export function find () {\n//\n// }","import { getHookedComponent } from \"./diff\";\nimport { LifecycleHandler, MountHandler } from \"./common\";\n\n// ----------------------------------------------------------------------------- MOUNT / UNMOUNT\n\nexport function mounted ( handler:MountHandler ) {\n\t// FIXME : In dev mode, maybe check if component is mounted ?\n\tgetHookedComponent()._mountHandlers.push( handler )\n}\n\nexport function unmounted ( handler:LifecycleHandler ) {\n\t// FIXME : In dev mode, maybe check if component is mounted ?\n\tgetHookedComponent()._unmountHandlers.push( handler )\n}\n\n// ----------------------------------------------------------------------------- TRACK CHANGE AFTER RENDER\n\ntype UnmountTrackHandler <GState> = (oldState:GState) => void\ntype TrackHandler <GState> = (newState:GState, oldState:GState) => UnmountTrackHandler<GState>|void\ntype DetectChanges <GState> = () => GState\n\nexport function changed <GState> ( detectChanges:DetectChanges<GState>|TrackHandler<GState>, executeHandler?:TrackHandler<GState> ) {\n\tconst component = getHookedComponent()\n\t// No executeHandler function means detectChanges has been omitted.\n\t// Do not check any change, just call executeHandler after every render.\n\tif ( !executeHandler ) {\n\t\tcomponent._renderHandlers.push( detectChanges );\n\t\treturn;\n\t}\n\t// Get first state\n\tlet state = (detectChanges as DetectChanges<GState>)()\n\t// Stored previous unmount handler\n\tlet previousUnmountHandler:LifecycleHandler\n\t// Update new state and call handlers\n\tfunction updateState ( oldState:GState ) {\n\t\t// Call previous handler with old state if it exists\n\t\tpreviousUnmountHandler && previousUnmountHandler( oldState );\n\t\t// Call executeHandler with new and old state\n\t\tconst executeResult = executeHandler( state, oldState )\n\t\t// Get previous unmount handler from return or cancel it\n\t\tpreviousUnmountHandler = (\n\t\t\t( typeof executeResult === \"function\" ) ? executeResult : null\n\t\t)\n\t}\n\t// After component just rendered\n\tlet firstRender = true\n\tcomponent._renderHandlers.push( () => {\n\t\t// Always execute handler at first render\n\t\tif ( firstRender ) {\n\t\t\tupdateState( null );\n\t\t\tfirstRender = false;\n\t\t} else {\n\t\t\t// Otherwise, detect changes\n\t\t\tconst oldState = state;\n\t\t\tstate = ( detectChanges as DetectChanges<GState> )()\n\t\t\tif ( oldState != state )\n\t\t\t\tupdateState( oldState )\n\t\t}\n\t})\n}\n","\n// ----------------------------------------------------------------------------- ENABLE / DISABLE\n\nlet _enableReflexDebug = false;\n\nexport function getReflexDebug () { return _enableReflexDebug }\nexport function setReflexDebug (value:boolean) {\n\t_enableReflexDebug = value\n}\n\n// ----------------------------------------------------------------------------- TRACK PERFORMANCES\n\nexport function trackPerformances ( subject:string ) {\n\tif ( !_enableReflexDebug || process.env.NODE_ENV === \"production\" )\n\t\treturn () => {};\n\tconst start = performance.now()\n\treturn () => {\n\t\tconst delta = ~~( performance.now() - start )\n\t\tconsole.info( subject, delta < 1000 ? `${delta}ms` : `${delta/1000}s`)\n\t}\n}","\nexport const toHex = (n:number) => (~~n).toString(16)\nexport const createUID = () => `${toHex(Date.now())}-${toHex(Math.random() * 999999999)}`;\nexport const pickRandom = <G extends any>(array:G[]):G => array[ ~~(Math.random() * array.length) ]\nexport const rand = (max:number) => ~~(Math.random() * max)\nexport const randBoolean = (threshold = .5) => (Math.random() > threshold)\n\nexport const foodList = [\"Cheese\", \"Carrots\", \"Pastas\", \"Pizza\", \"Burgers\", \"Ham\", \"Salad\", \"Mustard\"]\nexport const colorList = [\"Red\", \"Blue\", \"Yellow\", \"Purple\", \"Orange\", \"Black\", \"White\", \"Green\"]\nexport const firstnameList = [\"Alfred\", \"Jessica\", \"Gwen\", \"Jeanne\"]\nexport const lastnameList = [\"Dupont\", \"Smith\", \"Stevensen\", \"Odea\"]\n"],"names":["parcelRequire","$2f7240e2d23dac03$export$ceeaf1d175e97f72","$2f7240e2d23dac03$export$e4b5d84263764130","$2f7240e2d23dac03$export$bb7cd3edfc3b568a","Error","$2f7240e2d23dac03$export$bb76eed83315504c","window","queueMicrotask","h","setTimeout","$2f7240e2d23dac03$export$f042e3ffe0775958","item","Array","isArray","$2f7240e2d23dac03$export$ad59fee0807e8d38","vnode","props","children","flat","$4xUDA","$8aa3021def56a9de$export$ca000e230c0caa3e","initialValue","component","getHookedComponent","observable","$f58w7","createStateObservable","$vCAeY","invalidateComponent","_observables","push","$2rWHf","$b55a461f4688c32b$export$bb6b58cf236838ae","$b55a461f4688c32b$var$_IS_NON_DIMENSIONAL_REGEX","$b55a461f4688c32b$var$_CAPTURE_REGEX","$b55a461f4688c32b$var$_hookedComponent","$b55a461f4688c32b$export$cc5e6a61e45cbc80","$b55a461f4688c32b$var$getEventNameAndKey","name","dom","useCapture","replace","eventName","toLowerCase","slice","$b55a461f4688c32b$var$updateNodeRef","node","_ref","setFromVNode","$b55a461f4688c32b$export$a3ee0f3c7d610502","newNode","oldNode","isTextNode","type","_TEXT_NODE_TYPE_NAME","document","createTextNode","value","createElement","nodeValue","Object","keys","map","innerHTML","startsWith","eventKey","removeEventListener","removeAttribute","Map","addEventListener","filter","v","join","trim","k","style","key","setProperty","test","$b55a461f4688c32b$var$setStyle","setAttribute","$b55a461f4688c32b$export$a9ba2108cc3d85ae","newParentNode","oldParentNode","newChildren","oldChildren","parentDom","_keys","registerKey","c","newChildNode","$b55a461f4688c32b$export$5d8df66cb6ae1d8e","appendChild","lostIndexes","oldChild","oldParentKeys","collapseCount","i","keep","collapsedIndex","indexOf","insertBefore","_keep","oldChildNode","$fwkQu","recursivelyUpdateMountState","removeChild","$b55a461f4688c32b$var$renderComponentNode","_component","result","_render","apply","_propsProxy","$fhfO5","cloneVNode","renderResult","createComponentInstance","isFactory","a","b","pure","length","every","hasOwnProperty","set","flattenChildren","_isDirty","Element","isMounted","_renderHandlers","$2e085b009da21c57$export$bf5c4cf060303d58","ref","$2e085b009da21c57$export$ee4f9e12c0a92a1a","$2e085b009da21c57$export$dda1d9f60106f0e9","__self","__source","nodeProps","child","$eae8f6c98513451a$export$e298329876cd4b79","$eae8f6c98513451a$var$createPropsProxy","_mountHandlers","_unmountHandlers","proxy","Proxy","get","target","propName","undefined","ReflexError","newProps","$eae8f6c98513451a$export$67406a523b38756e","doMount","handler","mountedReturn","o","dispose","$eae8f6c98513451a$export$abce5757bf99796b","$81d9b1de2eabf71b$export$b3890eb0ae9dca99","rootNode","parentElement","root","createVNode","_ROOT_NODE_TYPE_NAME","forceArray","diffChildren","_DOM_PRIVATE_VIRTUAL_NODE_KEY","$81d9b1de2eabf71b$var$componentsToUpdate","$81d9b1de2eabf71b$var$updateDirtyComponents","diffNode","$81d9b1de2eabf71b$export$d86d0cc00dc6bc42","microtask","$kvonT","$67ba320a79f9dae6$export$2985e25a327f08f0","$67ba320a79f9dae6$var$prepareInitialValue","onChanged","Signal","dispatch","newValue","clear","$67ba320a79f9dae6$export$eaa260439225e231","beforeChanged","bit","async","oldValue","$67ba320a79f9dae6$export$914806c132e1f292","isChanging","wasAlreadyChanging","$6f1f8f6f71e328d0$export$8210dfe1863c478","_listeners","remove","l","add","once","callAtInit","rest","listener","listeners","$949571a43ff927b1$export$eff4d24c3ff7876e","$949571a43ff927b1$export$21666b427502ea6d","list","index","$814c192c3d6743bf$export$ccee69f0effb95fc","$814c192c3d6743bf$export$f603dcbfc05d17f4","$814c192c3d6743bf$export$a9c18da36281d08","detectChanges","executeHandler","previousUnmountHandler","state","updateState","oldState","executeResult","firstRender","$228131962d4ca37f$var$_enableReflexDebug","$228131962d4ca37f$export$d5718688a258fa1","$228131962d4ca37f$export$abc1990abd61cfda","subject","$00c98e03044c15dd$export$7ea66e3774a60b67","n","toString","$00c98e03044c15dd$export$c55f232b018cefe7","Date","now","Math","random","$00c98e03044c15dd$export$2e015b6955893291","array","$00c98e03044c15dd$export$bb0a9c36cf454ea0","max","$00c98e03044c15dd$export$e7f2be8fe70b5202","threshold","$00c98e03044c15dd$export$4815de0a6e6c5145","$00c98e03044c15dd$export$9afc515fe5566574","$00c98e03044c15dd$export$53266ee726a299e0","$00c98e03044c15dd$export$cfc29f1b5b07ff6b"],"version":3,"file":"index.2e7738bf.js.map"}